;主引导程序
;mbr.S
;------------------------------------------------------------
SECTION MBR vstart=0x7c00 ;把地址编译为0x7c00 SECTION 伪指令
   mov ax,cs
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov fs,ax
   mov sp,0x7c00

; 清屏利用0x06号功能，上卷全部行，则可清屏
; -----------------------------------------------------------
;INT 0x10   功能号:0x06       功能描述:上卷窗口
;------------------------------------------------------
;输入
;AH 功能号= 0x06
;AL = 上卷行数(如果为零,表示全部)
;BH = 上卷行属性
;(CL,CH) =窗口左上角的(X,Y)位置
;(DL,DH) = 窗口右下角(X,Y)位置
;无返回值
   mov     ax, 0x600
   mov     bx, 0x700
   mov     cx, 0        ; 左上角: (0, 0)
   mov     dx, 0x184f   ; 右下角: (80,25),
                        ; 80个字符 25行
                        ; 从下标0开始,所以0x18=24,0x4f=79
   int     0x10         ; int 0x10

;;;;;;;;;   下面这三行获取光标位置    ;;;;;;;;;
;.get_cursor获取当前光标位置，在光标位置打印字符
   mov ah, 3            ; 3号子功能获取当前光标位置，
   mov bh, 0            ; bh寄存器存储的是获取光标的页数

   int 0x10             ; 输出: ch=光标开始,cl=光标结束
                        ; dh=光标所在行号dl=光标所在列号

;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;

;;;;;;;;;     打印字符    ;;;;;;;;;;;
   ;int 10 调用13号子功能
   mov ax, message
   mov bp, ax       ; es:bp 为首地址, es此时和cs一致
                    ; 开头已经初始化了sreg 初始化

   ; 光标位置要用到dx寄存器中的内容，cx中的光标长度可以忽略
   mov cx, 5        ; cx为串长度，不包括结束符0的字符个数
   mov ax, 0x1301   ;子功能号13是显示字符和属性，要存入ah寄存器
                    ; al设置写字符方式al=01 显示字符串 光标跟随移动
   mov bx, 0x2      ; bh存储要显示的页号，此处是第0页
                    ;bl中是字符属性(bl = 02h)
   int 0x10         ; ִ执行BIOS 0x10 中断
;;;;;;;;;      打印字符结束    ;;;;;;;;;;;;;;;

   jmp $            ; 使程序悬停在此处

   message db "1 MBR"
   times 510-($-$$) db 0 ;;为了是程序凑够510 字节
   db 0x55,0xaa